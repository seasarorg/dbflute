${database.allClassCopyright}package ${glPackageBaseCommonBhv};

#set ($myClassName = "${glBehaviorWritableAbstractName}")
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

import ${glPackageBaseCommon}.${glEntityInterfaceName};
import ${glPackageBaseCommonBhvCoreCommand}.${glAbstractEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glAbstractListEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glInsertEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glUpdateEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glUpdateNonstrictEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glDeleteEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glDeleteNonstrictEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glBatchInsertEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glBatchUpdateEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glBatchUpdateNonstrictEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glBatchDeleteEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glBatchDeleteNonstrictEntityCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glQueryDeleteCBCommand};
import ${glPackageBaseCommonBhvCoreCommand}.${glQueryUpdateEntityCBCommand};
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderName};
import ${glPackageBaseCommonHelper}.${glMapStringBuilderImplName};

import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionOptionName};
import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionResultName};
import ${glPackageBaseCommonBhvBatch}.${glTokenFileReflectionFailureName};

import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingCallbackName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingRowResourceName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingHeaderInfoName};
import ${glPackageBaseCommonHelperTokenFile}.${glFileTokenizingOptionName};
import ${glPackageBaseCommonHelperTokenFileImpl}.${glFileTokenImplName};

/**
 * The abstract class of behavior-writable.
 * @author ${database.ClassAuthor}
 */
public abstract class ${myClassName} extends ${glBehaviorReadableAbstractName} implements ${glBehaviorWritableInterfaceName} {

    // ===================================================================================
    //                                                                          Definition
    //                                                                          ==========
    /** Map-string map-mark. */
    private static final String MAP_STRING_MAP_MARK = "map:";

    /** Map-string list-mark. */
    private static final String MAP_STRING_LIST_MARK = "list:";

    /** Map-string start-brace. */
    private static final String MAP_STRING_START_BRACE = "${database.extractAcceptStartBrace}";

    /** Map-string end-brace. */
    private static final String MAP_STRING_END_BRACE = "${database.extractAcceptEndBrace}";

    /** Map-string delimiter. */
    private static final String MAP_STRING_DELIMITER = "${database.extractAcceptDelimiter}";

    /** Map-string equal. */
    private static final String MAP_STRING_EQUAL = "${database.extractAcceptEqual}";
#if ($database.isExistCommonColumnSetupElement())

    /** Log instance. */
    private static final org.apache.commons.logging.Log _log = org.apache.commons.logging.LogFactory.getLog(${myClassName}.class);
#end

#if ($database.hasCommonColumnSetupResource())
    // =====================================================================================
    //                                                                             Attribute
    //                                                                             =========
#foreach ($resource in $database.commonColumnSetupResourceList)
    /** The property of ${resource.propertyName}. */
    protected ${resource.className} ${resource.propertyVariableName};

    /**
     * @return The value of ${resource.propertyName}.
     */
    public ${resource.className} get${resource.propertyNameInitCap}() {
        return ${resource.propertyVariableName};
    }

    /**
     * @param ${resource.propertyName} The value of ${resource.propertyName}.
     */
    public void set${resource.propertyNameInitCap}(${resource.className} ${resource.propertyName}) {
        this.${resource.propertyVariableName} = ${resource.propertyName};
    }

#end
#end
    // ===================================================================================
    //                                                                       Entity Update
    //                                                                       =============
    // -----------------------------------------------------
    //                                                Create
    //                                                ------
    /**
     * Create.
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyExistsException} When the entity already exists. (Unique Constraint Violation)
     */
    public void create(${glEntityInterfaceName} entity) {
        doCreate(entity);
    }

    protected abstract void doCreate(${glEntityInterfaceName} entity);

    // -----------------------------------------------------
    //                                                Modify
    //                                                ------
    /**
     * Modify.
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyExistsException} When the entity already exists. (Unique Constraint Violation)
     */
    public void modify(${glEntityInterfaceName} entity) {
        doModify(entity);
    }

    protected abstract void doModify(${glEntityInterfaceName} entity);

    /**
     * Modify non strict.
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyExistsException} When the entity already exists. (Unique Constraint Violation)
     */
    public void modifyNonstrict(${glEntityInterfaceName} entity) {
        doModifyNonstrict(entity);
    }

    protected abstract void doModifyNonstrict(${glEntityInterfaceName} entity);

    // -----------------------------------------------------
    //                                      Create or Modify
    //                                      ----------------
    /**
     * ${database.ImplementComment}
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyExistsException} When the entity already exists. (Unique Constraint Violation)
     */
    public void createOrModify(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        doCreateOrUpdate(entity);
    }

    protected abstract void doCreateOrUpdate(${glEntityInterfaceName} entity);

    /**
     * ${database.ImplementComment}
     * @param entity Entity. This must contain primary-key value at least(Except use identity). (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyExistsException} When the entity already exists. (Unique Constraint Violation)
     */
    public void createOrModifyNonstrict(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        doCreateOrUpdateNonstrict(entity);
    }

    protected abstract void doCreateOrUpdateNonstrict(${glEntityInterfaceName} entity);

    // -----------------------------------------------------
    //                                                Remove
    //                                                ------
    /**
     * Remove.
     * @param entity Entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void remove(${glPackageBaseCommon}.${glEntityInterfaceName} entity) {
        assertEntityNotNull(entity);
        callRemove(entity);
    }

    protected abstract void doRemove(${glEntityInterfaceName} entity);

    // ===================================================================================
    //                                                       Entity Update Internal Helper
    //                                                       =============================
    // -----------------------------------------------------
    //                                                Update
    //                                                ------
    protected <ENTITY extends ${glEntityInterfaceName}> void helpUpdateInternally(ENTITY entity, InternalUpdateCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        assertEntityHasVersionNoValue(entity);
        assertEntityHasUpdateDateValue(entity);
        final int updatedCount = callback.callbackDelegateUpdate(entity);
        if (updatedCount == 0) {
            String msg = "The entity was Not Found! it has already been deleted: entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        } else if (updatedCount > 1) {
            String msg = "The entity was Too Many! it has been duplicated. It should be the only one! But the updatedCount=" + updatedCount;
            msg = msg + ": entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalUpdateCallback<ENTITY extends ${glEntityInterfaceName}> {
        public int callbackDelegateUpdate(ENTITY entity);
    }

    protected <ENTITY extends ${glEntityInterfaceName}> void helpUpdateNonstrictInternally(ENTITY entity, InternalUpdateNonstrictCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        final int updatedCount = callback.callbackDelegateUpdateNonstrict(entity);
        if (updatedCount == 0) {
            String msg = "The entity was Not Found! it has already been deleted: entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        } else if (updatedCount > 1) {
            String msg = "The entity was Too Many! it has been duplicated. It should be the only one! But the updatedCount=" + updatedCount;
            msg = msg + ": entity=" + entity;
        }
    }

    protected static interface InternalUpdateNonstrictCallback<ENTITY extends ${glEntityInterfaceName}> {
        public int callbackDelegateUpdateNonstrict(ENTITY entity);
    }

    // -----------------------------------------------------
    //                                        InsertOrUpdate
    //                                        --------------
    protected <ENTITY extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}>
            void helpInsertOrUpdateInternally(ENTITY entity, InternalInsertOrUpdateCallback<ENTITY, CB_TYPE> callback) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            callback.callbackInsert(entity);
        } else {
            RuntimeException exception = null;
            try {
                callback.callbackUpdate(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} e) {
                if (e.getRows() == 0) {
                    exception = e;
                }
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} e) {
                exception = e;
            } catch (OptimisticLockColumnValueNullException e) {
                exception = e;
            }
            if (exception != null) {
                final CB_TYPE cb = callback.callbackNewMyConditionBean();
                cb.acceptPrimaryKeyMapString(getDBMeta().extractPrimaryKeyMapString(entity));
                if (callback.callbackSelectCount(cb) == 0) {
                    callback.callbackInsert(entity);
                } else {
                    throw exception;
                }
            }
        }
    }

    protected static interface InternalInsertOrUpdateCallback<ENTITY extends ${glEntityInterfaceName}, CB_TYPE extends ${glConditionBeanInterfaceName}> {
        public void callbackInsert(ENTITY entity);
        public void callbackUpdate(ENTITY entity);
        public CB_TYPE callbackNewMyConditionBean();
        public int callbackSelectCount(CB_TYPE cb);
    }

    protected <ENTITY extends ${glEntityInterfaceName}> void helpInsertOrUpdateInternally(ENTITY entity, InternalInsertOrUpdateNonstrictCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        if (!entity.hasPrimaryKeyValue()) {
            callback.callbackInsert(entity);
        } else {
            try {
                callback.callbackUpdateNonstrict(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} e) {
                callback.callbackInsert(entity);
            } catch (${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} e) {
                callback.callbackInsert(entity);
            }
        }
    }

    protected static interface InternalInsertOrUpdateNonstrictCallback<ENTITY extends ${glEntityInterfaceName}> {
        public void callbackInsert(ENTITY entity);
        public void callbackUpdateNonstrict(ENTITY entity);
    }

    // -----------------------------------------------------
    //                                                Delete
    //                                                ------
    protected <ENTITY extends ${glEntityInterfaceName}> void helpDeleteInternally(ENTITY entity, InternalDeleteCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        assertEntityHasVersionNoValue(entity);
        assertEntityHasUpdateDateValue(entity);
        final int deletedCount = callback.callbackDelegateDelete(entity);
        if (deletedCount == 0) {
            String msg = "The entity was Not Found! The entity has already been deleted: entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        } else if (deletedCount > 1) {
            String msg = "The deleted entity was duplicated. It should be the only one! But the deletedCount=" + deletedCount;
            msg = msg + ": entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteCallback<ENTITY extends ${glEntityInterfaceName}> {
        public int callbackDelegateDelete(ENTITY entity);
    }

    protected <ENTITY extends ${glEntityInterfaceName}> void helpDeleteNonstrictInternally(ENTITY entity, InternalDeleteNonstrictCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        final int deletedCount = callback.callbackDelegateDeleteNonstrict(entity);
        if (deletedCount == 0) {
            String msg = "The entity was Not Found! The entity has already been deleted: entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}(msg);
        } else if (deletedCount > 1) {
            String msg = "The deleted entity was duplicated. It should be the only one! But the deletedCount=" + deletedCount;
            msg = msg + ": entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteNonstrictCallback<ENTITY extends ${glEntityInterfaceName}> {
        public int callbackDelegateDeleteNonstrict(ENTITY entity);
    }

    protected <ENTITY extends ${glEntityInterfaceName}> void helpDeleteNonstrictIgnoreDeletedInternally(ENTITY entity, InternalDeleteNonstrictIgnoreDeletedCallback<ENTITY> callback) {
        assertEntityNotNull(entity);
        final int deletedCount = callback.callbackDelegateDeleteNonstrict(entity);
        if (deletedCount == 0) {
            return;
        } else if (deletedCount > 1) {
            String msg = "The deleted entity was duplicated. It should be the only one! But the deletedCount=" + deletedCount;
            msg = msg + ": entity=" + entity;
            throw new ${glPackageBaseCommonException}.${glEntityDuplicatedException}(msg);
        }
    }

    protected static interface InternalDeleteNonstrictIgnoreDeletedCallback<ENTITY extends ${glEntityInterfaceName}> {
        public int callbackDelegateDeleteNonstrict(ENTITY entity);
    }

    // ===================================================================================
    //                                                                         Lump Update
    //                                                                         ===========
    /**
     * Lump create the list.
     * @param entityList Entity list. (NotNull and NotEmpty)
     * @return The array of created count.
     */
    public int[] lumpCreate(List<${glEntityInterfaceName}> entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callCreateList(entityList);
    }

    /**
     * Lump Modify the list.
     * @param entityList Entity list. (NotNull and NotEmpty)
     * @return Modified count.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} If s2dao's version is over 1.0.47 (contains 1.0.47).
     */
    public int[] lumpModify(List<${glEntityInterfaceName}> entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callModifyList(entityList);
    }

    /**
     * Lump remove the list.
     * @param entityList Entity list. (NotNull and NotEmpty)
     * @return Removed count.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} If s2dao's version is over 1.0.47 (contains 1.0.47).
     */
    public int[] lumpRemove(List<${glEntityInterfaceName}> entityList) {
        assertListNotNullAndNotEmpty(entityList);
        return callRemoveList(entityList);
    }

    /**
     * Inject sequence to primary key if it needs.
     * @param entity Entity. (NotNull)
     */
    protected void injectSequenceToPrimaryKeyIfNeeds(${glEntityInterfaceName} entity) {
        final ${glDBMetaInterfaceName} dbmeta = entity.getDBMeta();
        if (!dbmeta.hasSequence() || dbmeta.hasTwoOrMorePrimaryKeys() || entity.hasPrimaryKeyValue()) {
            return;
        }
        final ${database.sequenceReturnType} sequenceValue = readNextVal();
        final String columnDbName = dbmeta.getPrimaryUniqueInfo().getFirstColumn().getColumnDbName();
        final java.util.Map${database.filterGenericsString('String, String')} map = new java.util.HashMap${database.filterGenericsString('String, String')}();
        map.put(columnDbName, sequenceValue.toString());
        dbmeta.acceptPrimaryKeyMap(entity, map);
    }

    // =====================================================================================
    //                                                                            Token File
    //                                                                            ==========
    public TokenFileReflectionExecutor tokenFileReflection() {
        return new TokenFileReflectionExecutor();
    }

    public class TokenFileReflectionExecutor {

        /**
         * Reflect(insert or update) token-file to this table.
         * @param filename Name of the file. (NotNull and NotEmpty)
         * @param tokenFileReflectionOption token-file-reflection-option. (NotNull and Required{delimiter and encoding})
         * @return Token-file-reflection-result. (NotNull)
         * @throws java.io.FileNotFoundException
         * @throws java.io.IOException
         */
        public ${glTokenFileReflectionResultName} reflectTokenFile(String filename, ${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
            assertStringNotNullAndNotTrimmedEmpty("filename", filename);
            assertFileTokenReflectionOption(tokenFileReflectionOption);

            final ${glTokenFileReflectionResultName} result = buildTokenFileReflectionResult();
            final ${glFileTokenizingCallbackName} fileTokenizingCallback = buildFileTokenReflectionFileTokenizingCallback(tokenFileReflectionOption, result);
            final ${glFileTokenizingOptionName} fileTokenizingOption = buildFileTokenReflectionFileTokenizingOption(tokenFileReflectionOption);
            final ${glFileTokenName} fileToken = new ${glFileTokenImplName}();
            fileToken.tokenize(filename, fileTokenizingCallback, fileTokenizingOption);
            return result;
        }

        /**
         * Reflect(insert or update) token-file to this table.
         * @param inputStream Input stream. (NotNull and NotClosed)
         * @param tokenFileReflectionOption token-file-reflection-option. (NotNull and Required{delimiter and encoding})
         * @return Token-file-reflection-result. (NotNull)
         * @throws java.io.FileNotFoundException
         * @throws java.io.IOException
         */
        public ${glTokenFileReflectionResultName} reflectTokenFile(java.io.InputStream inputStream, ${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
            assertObjectNotNull("inputStream", inputStream);
            assertFileTokenReflectionOption(tokenFileReflectionOption);

            final ${glTokenFileReflectionResultName} result = buildTokenFileReflectionResult();
            final ${glFileTokenizingCallbackName} fileTokenizingCallback = buildFileTokenReflectionFileTokenizingCallback(tokenFileReflectionOption, result);
            final ${glFileTokenizingOptionName} fileTokenizingOption = buildFileTokenReflectionFileTokenizingOption(tokenFileReflectionOption);
            final ${glFileTokenName} fileToken = new ${glFileTokenImplName}();
            fileToken.tokenize(inputStream, fileTokenizingCallback, fileTokenizingOption);
            return result;
        }

        protected void assertFileTokenReflectionOption(${glTokenFileReflectionOptionName} tokenFileReflectionOption) {
            assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

            final String encoding = tokenFileReflectionOption.getEncoding();
            final String delimiter = tokenFileReflectionOption.getDelimiter();
            assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
            assertObjectNotNull("delimiter", delimiter);
        }

        protected ${glTokenFileReflectionResultName} buildTokenFileReflectionResult() {
            final ${glTokenFileReflectionResultName} result = new ${glTokenFileReflectionResultName}();
            final java.util.List${database.filterGenericsString(${glTokenFileReflectionFailureName})} failureList = new java.util.ArrayList${database.filterGenericsString(${glTokenFileReflectionFailureName})}();
            result.setFailureList(failureList);
            return result;
        }

        protected ${glFileTokenizingCallbackName} buildFileTokenReflectionFileTokenizingCallback(${glTokenFileReflectionOptionName} tokenFileReflectionOption, final ${glTokenFileReflectionResultName} result) throws java.io.FileNotFoundException, java.io.IOException {
            assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

            final String encoding = tokenFileReflectionOption.getEncoding();
            final String delimiter = tokenFileReflectionOption.getDelimiter();
            final boolean interruptIfError = tokenFileReflectionOption.isInterruptIfError();
            assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
            assertObjectNotNull("delimiter", delimiter);
            final java.util.List${database.filterGenericsString(${glTokenFileReflectionFailureName})} failureList = result.getFailureList();
            assertObjectNotNull("failureList", failureList);

            final ${glFileTokenizingCallbackName} fileTokenizingCallback = new ${glFileTokenizingCallbackName}() {
                public void handleRowResource(${glFileTokenizingRowResourceName} fileTokenizingRowResource) {
                    final ${glFileTokenizingHeaderInfoName} fileTokenizingHeaderInfo = fileTokenizingRowResource.getFileTokenizingHeaderInfo();
                    final java.util.List${database.filterGenericsString('String')} columnNameList = fileTokenizingHeaderInfo.getColumnNameList();
                    final java.util.List${database.filterGenericsString('String')} valueList = fileTokenizingRowResource.getValueList();

                    // Set up columnNameList of result object.
                    if (result.getColumnNameList() == null) {
                        result.setColumnNameList(columnNameList);
                    }

                    ${glEntityInterfaceName} entity = null;
                    try {
                        // Create entity by the list of value composed of String.
                        entity = createEntityByStringValueList(columnNameList, valueList);

                        // Create or modify as non-strict.
                        doCreateOrUpdateNonstrict(entity);

                        // Increment successCount of result object.
                        result.incrementSuccessCount();
                    } catch (RuntimeException e) {
                        if (interruptIfError) {
                            throw e;
                        }
                        final ${glTokenFileReflectionFailureName} failure = new ${glTokenFileReflectionFailureName}();
                        failure.setColumnNameList(columnNameList);
                        failure.setValueList(valueList);
                        failure.setRowString(fileTokenizingRowResource.getRowString());
                        failure.setRowNumber(fileTokenizingRowResource.getRowNumber());
                        failure.setLineNumber(fileTokenizingRowResource.getLineNumber());
                        if (entity != null) {
                            failure.setEntity(entity);
                        }
                        failure.setException(e);
                        failureList.add(failure);
                    }
                }
            };
            return fileTokenizingCallback;
        }

        protected ${glEntityInterfaceName} createEntityByStringValueList(java.util.List${database.filterGenericsString('String')} columnNameList, java.util.List${database.filterGenericsString('String')} valueList) {
            final ${glMapStringBuilderName} builder = new ${glMapStringBuilderImplName}();
            builder.setMsMapMark(MAP_STRING_MAP_MARK);
            builder.setMsStartBrace(MAP_STRING_START_BRACE);
            builder.setMsEndBrace(MAP_STRING_END_BRACE);
            builder.setMsDelimiter(MAP_STRING_DELIMITER);
            builder.setMsEqual(MAP_STRING_EQUAL);
            builder.setColumnNameList(columnNameList);
            final String mapString = builder.buildFromList(valueList);

            final ${glEntityInterfaceName} entity = getDBMeta().newEntity();
            getDBMeta().acceptColumnValueMapString(entity, mapString);
            return entity;
        }

        protected ${glFileTokenizingOptionName} buildFileTokenReflectionFileTokenizingOption(${glTokenFileReflectionOptionName} tokenFileReflectionOption) throws java.io.FileNotFoundException, java.io.IOException {
            assertObjectNotNull("tokenFileReflectionOption", tokenFileReflectionOption);

            final String encoding = tokenFileReflectionOption.getEncoding();
            final String delimiter = tokenFileReflectionOption.getDelimiter();
            assertStringNotNullAndNotTrimmedEmpty("encoding", encoding);
            assertObjectNotNull("delimiter", delimiter);

            final ${glFileTokenizingOptionName} fileTokenizingOption = new ${glFileTokenizingOptionName}();
            fileTokenizingOption.setEncoding(encoding);
            fileTokenizingOption.setDelimiter(delimiter);
            if (tokenFileReflectionOption.isHandleEmptyAsNull()) {
                fileTokenizingOption.handleEmptyAsNull();
            }
            return fileTokenizingOption;
        }
    }


    // =====================================================================================
    //                                                                       Delegate Method
    //                                                                       ===============
    // -----------------------------------------------------
    //                                                Insert
    //                                                ------
    /**
     * ${database.ImplementComment}
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Inserted count.
     */
    protected int callCreate(${glEntityInterfaceName} entity) {
        if (!processBeforeInsert(entity)) { return 1;/*as Normal End*/ }
        return doCallCreate(entity);
    }
    protected abstract int doCallCreate(${glEntityInterfaceName} entity);

    /**
     * Process before insert.
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean processBeforeInsert(${glEntityInterfaceName} entity) {
        if (!determineExecuteInsert(entity)) { return false; }
        assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
        frameworkFilterEntityOfInsert(entity);
        filterEntityOfInsert(entity);
        assertEntityOfInsert(entity);
        return true;
    }

    // -----------------------------------------------------
    //                                                Update
    //                                                ------
    /**
     * ${database.ImplementComment}
     * {modified only}
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Updated count.
     */
    protected int callModify(${glEntityInterfaceName} entity) {
        if (!processBeforeUpdate(entity)) { return 1;/*as Normal End*/ }
        return doCallModify(entity);
    }
    protected abstract int doCallModify(${glEntityInterfaceName} entity);

    /**
     * Process before update.
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean processBeforeUpdate(${glEntityInterfaceName} entity) {
        if (!determineExecuteUpdate(entity)) { return false; }
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        frameworkFilterEntityOfUpdate(entity);
        filterEntityOfUpdate(entity);
        assertEntityOfUpdate(entity);
        return true;
    }

    // -----------------------------------------------------
    //                                                Delete
    //                                                ------
    /**
     * ${database.ImplementComment}
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Deleted count.
     */
    protected int callRemove(${glEntityInterfaceName} entity) {
        if (!processBeforeDelete(entity)) { return 1;/*as Normal End*/ }
        return doCallRemove(entity);
    }
    protected abstract int doCallRemove(${glEntityInterfaceName} entity);

    /**
     * Process before delete.
     * @param entity Entity that the type is entity interface. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean processBeforeDelete(${glEntityInterfaceName} entity) {
        if (!determineExecuteDelete(entity)) { return false; }
        assertEntityNotNullAndHasPrimaryKeyValue(entity);
        frameworkFilterEntityOfDelete(entity);
        filterEntityOfDelete(entity);
        assertEntityOfDelete(entity);
        return true;
    }

    // -----------------------------------------------------
    //                                    Pre-Process Insert
    //                                    ------------------
    /**
     * Determine execution of insert.
     * @param entity Entity. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean determineExecuteInsert(${glEntityInterfaceName} entity) {
        return true;
    }

    /**
     * {Framework Method} Filter the entity of insert.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void frameworkFilterEntityOfInsert(${glEntityInterfaceName} targetEntity) {
#if ($database.isAvailableBehaviorInsertSequenceInjection())
        injectSequenceToPrimaryKeyIfNeeds(targetEntity);
#end
		setupCommonColumnOfInsertIfNeeds(targetEntity);
    }

    /**
     * Set up common columns of insert if it needs.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
	protected void setupCommonColumnOfInsertIfNeeds(${glEntityInterfaceName} targetEntity) {
#if ($database.isExistCommonColumnSetupElement())
        if (!(targetEntity instanceof ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})) {
            return;
        }
        final ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName} entity = (${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})targetEntity;
		if (!entity.canCommonColumnAutoSetup()) {
		    return;
		}
        if (_log.isDebugEnabled()) {
            String msg = "...Filtering entity of INSERT about the column columns of " + getTableDbName();
            msg = msg + ": entity=" + entity.getDBMeta().extractPrimaryKeyMapString(entity, "{", "}", ", ", "=");
            _log.debug(msg);
        }
#foreach ($columnName in ${database.commonColumnNameList})
  #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
  #set ($entityCommonColumnMap = ${database.commonColumnMap})
  #set ($columnType = ${entityCommonColumnMap.get(${columnName})})
  #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
  #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #set ($uncapitalisedJavaName = ${database.convertUncapitalisedJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #if (${database.containsValidColumnNameKeyCommonColumnSetupBeforeInsertInterceptorLogicMap(${columnName})})
    #set ($logic = ${database.getCommonColumnSetupBeforeInsertInterceptorLogicByColumnName(${columnName})})
    #if ($database.isCommonColumnSetupInvokingLogic($logic))
      #set ($filteredLogic = $database.removeCommonColumnSetupInvokingMark($logic))

        ${filteredLogic}
    #else

        final ${javaNative} ${uncapitalisedJavaName} = ${logic};
        entity.set${javaName}(${uncapitalisedJavaName});
    #end
  #end
#end
#end
	}
	
    /**
     * Filter the entity of insert.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void filterEntityOfInsert(${glEntityInterfaceName} targetEntity) {
    }

    /**
     * Assert the entity of insert.
     * @param entity Entity that the type is entity interface. (NotNull)
     */
    protected void assertEntityOfInsert(${glEntityInterfaceName} entity) {
    }

    // -----------------------------------------------------
    //                                    Pre-Process Update
    //                                    ------------------
    /**
     * Determine execution of update.
     * @param entity Entity. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean determineExecuteUpdate(${glEntityInterfaceName} entity) {
        return true;
    }

    /**
     * {Framework Method} Filter the entity of update.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void frameworkFilterEntityOfUpdate(${glEntityInterfaceName} targetEntity) {
	    setupCommonColumnOfUpdateIfNeeds(targetEntity);
    }

    /**
     * Set up common columns of update if it needs.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
	protected void setupCommonColumnOfUpdateIfNeeds(${glEntityInterfaceName} targetEntity) {
#if ($database.isExistCommonColumnSetupElement())
        if (!(targetEntity instanceof ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})) {
            return;
        }
        final ${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName} entity = (${glPackageBaseCommon}.${glEntityDefinedCommonColumnInterfaceName})targetEntity;
		if (!entity.canCommonColumnAutoSetup()) {
		    return;
		}
        if (_log.isDebugEnabled()) {
            String msg = "...Filtering entity of UPDATE about the column columns of " + getTableDbName();
            msg = msg + ": entity=" + entity.getDBMeta().extractPrimaryKeyMapString(entity, "{", "}", ", ", "=");
            _log.debug(msg);
        }
#foreach ($columnName in ${database.commonColumnNameList})
  #set ($filteredColumnName = ${database.filterCommonColumn(${columnName})})
  #set ($entityCommonColumnMap = ${database.CommonColumnMap})
  #set ($columnType = ${entityCommonColumnMap.get(${columnName})})
  #set ($javaNative = ${database.convertJavaNativeByJdbcType(${columnType})})
  #set ($javaName = ${database.convertJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #set ($uncapitalisedJavaName = ${database.convertUncapitalisedJavaNameByJdbcNameAsColumn(${filteredColumnName})})
  #if (${database.containsValidColumnNameKeyCommonColumnSetupBeforeUpdateInterceptorLogicMap(${columnName})})
    #set ($logic = ${database.getCommonColumnSetupBeforeUpdateInterceptorLogicByColumnName(${columnName})})
    #if ($database.isCommonColumnSetupInvokingLogic($logic))
      #set ($filteredLogic = $database.removeCommonColumnSetupInvokingMark($logic))

        ${filteredLogic}
    #else

        final ${javaNative} ${uncapitalisedJavaName} = ${logic};
        entity.set${javaName}(${uncapitalisedJavaName});
    #end
  #end
#end
#end
	}
	
    /**
     * Filter the entity of update.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void filterEntityOfUpdate(${glEntityInterfaceName} targetEntity) {
    }

    /**
     * Assert the entity of update.
     * @param entity Entity that the type is entity interface. (NotNull)
     */
    protected void assertEntityOfUpdate(${glEntityInterfaceName} entity) {
    }

    // -----------------------------------------------------
    //                                    Pre-Process Delete
    //                                    ------------------
    /**
     * Determine execution of delete.
     * @param entity Entity. (NotNull)
     * @return Execution Determination. (true: execute / false: non)
     */
    protected boolean determineExecuteDelete(${glEntityInterfaceName} entity) {
        return true;
    }

    /**
     * {Framework Method} Filter the entity of delete.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void frameworkFilterEntityOfDelete(${glEntityInterfaceName} targetEntity) {
    }
	
    /**
     * Filter the entity of delete.
     * @param targetEntity Target entity that the type is entity interface. (NotNull)
     */
    protected void filterEntityOfDelete(${glEntityInterfaceName} targetEntity) {
    }

    /**
     * Assert the entity of delete.
     * @param entity Entity that the type is entity interface. (NotNull)
     */
    protected void assertEntityOfDelete(${glEntityInterfaceName} entity) {
    }

    /**
     * ${database.ImplementComment}
     * @param entityList Entity list that the type is entity interface. (NotNull)
     * @return Inserted count.
     */
    public int[] callCreateList(List<${glEntityInterfaceName}> entityList) {
        assertObjectNotNull("entityList", entityList);
        helpFilterBeforeInsertInternally(entityList);
        return doCreateList(entityList);
    }
    protected abstract int[] doCreateList(List<${glEntityInterfaceName}> entityList);

    /**
     * ${database.ImplementComment}
     * @param entityList Entity list that the type is entity interface. (NotNull)
     * @return Updated count.
     */
    public int[] callModifyList(List<${glEntityInterfaceName}> entityList) {
        assertObjectNotNull("entityList", entityList);
        helpFilterBeforeUpdateInternally(entityList);
        return doModifyList(entityList);
    }
    protected abstract int[] doModifyList(List<${glEntityInterfaceName}> entityList);

    /**
     * ${database.ImplementComment}
     * @param entityList Entity list that the type is entity interface. (NotNull)
     * @return Deleted count.
     */
    public int[] callRemoveList(List<${glEntityInterfaceName}> entityList) {
        assertObjectNotNull("entityList", entityList);
        helpFilterBeforeDeleteInternally(entityList);
        return doRemoveList(entityList);
    }
    protected abstract int[] doRemoveList(List<${glEntityInterfaceName}> entityList);

    protected void assertEntityHasVersionNoValue(${glEntityInterfaceName} entity) {
        if (!getDBMeta().hasVersionNo()) {
            return;
        }
        if (hasVersionNoValue(entity)) {
            return;
        }
        String msg = "Look! Read the message below." + getLineSeparator();
        msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
        msg = msg + "The value of 'version no' on the entity was Not Found!" + getLineSeparator() + getLineSeparator();
        msg = msg + "[Advice]" + getLineSeparator();
        msg = msg + "Please confirm the existence of the value of 'version no' on the entity." + getLineSeparator();
        msg = msg + "You called the method in which the check for optimistic lock is indispensable. " + getLineSeparator();
        msg = msg + "So 'version no' is required on the entity. " + getLineSeparator();
        msg = msg + "In addition, please confirm the necessity of optimistic lock. It might possibly be unnecessary." + getLineSeparator() + getLineSeparator();
        msg = msg + "[Entity]" + getLineSeparator();
        msg = msg + "entity to string = " + entity + getLineSeparator();
        msg = msg + "entity to map    = " + entity.getDBMeta().convertToColumnValueMap(entity) + getLineSeparator();
        msg = msg + "* * * * * * * * * */" + getLineSeparator();
        throw new OptimisticLockColumnValueNullException(msg);
    }

    protected void assertEntityHasUpdateDateValue(${glEntityInterfaceName} entity) {
        if (!getDBMeta().hasUpdateDate()) {
            return;
        }
        if (hasUpdateDateValue(entity)) {
            return;
        }
        String msg = "Look! Read the message below." + getLineSeparator();
        msg = msg + "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *" + getLineSeparator();
        msg = msg + "The value of 'update date' on the entity was Not Found!" + getLineSeparator() + getLineSeparator();
        msg = msg + "[Advice]" + getLineSeparator();
        msg = msg + "Please confirm the existence of the value of 'update date' on the entity." + getLineSeparator();
        msg = msg + "You called the method in which the check for optimistic lock is indispensable. " + getLineSeparator();
        msg = msg + "So 'update date' is required on the entity. " + getLineSeparator();
        msg = msg + "In addition, please confirm the necessity of optimistic lock. It might possibly be unnecessary." + getLineSeparator() + getLineSeparator();
        msg = msg + "[Entity]" + getLineSeparator();
        msg = msg + "entity to string = " + entity + getLineSeparator();
        msg = msg + "entity to map    = " + entity.getDBMeta().convertToColumnValueMap(entity) + getLineSeparator();
        msg = msg + "* * * * * * * * * */" + getLineSeparator();
        throw new OptimisticLockColumnValueNullException(msg);
    }

    public static class OptimisticLockColumnValueNullException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        public OptimisticLockColumnValueNullException(String msg) {
            super(msg);
        }
    }

    // ===================================================================================
    //                                                     Delegate Method Internal Helper
    //                                                     ===============================
    protected <ENTITY extends ${glEntityInterfaceName}> List<ENTITY> helpFilterBeforeInsertInternally(List<ENTITY> entityList) {
	    final List<ENTITY> filteredList = new ArrayList<ENTITY>();
        for (final Iterator<ENTITY> ite = entityList.iterator(); ite.hasNext(); ) {
            final ENTITY entity = ite.next();
            if (!processBeforeInsert(entity)) { continue; }
			filteredList.add(entity);
        }
		return filteredList;
    }

    protected <ENTITY extends ${glEntityInterfaceName}> List<ENTITY> helpFilterBeforeUpdateInternally(List<ENTITY> entityList) {
	    final List<ENTITY> filteredList = new ArrayList<ENTITY>();
        for (final Iterator<ENTITY> ite = entityList.iterator(); ite.hasNext(); ) {
            final ENTITY entity = ite.next();
            if (!processBeforeUpdate(entity)) { continue; }
			filteredList.add(entity);
        }
		return filteredList;
    }

    protected <ENTITY extends ${glEntityInterfaceName}> List<ENTITY> helpFilterBeforeDeleteInternally(List<ENTITY> entityList) {
		final List<ENTITY> filteredList = new ArrayList<ENTITY>();
        for (final Iterator<ENTITY> ite = entityList.iterator(); ite.hasNext(); ) {
            final ENTITY entity = ite.next();
            if (!processBeforeDelete(entity)) { continue; }
			filteredList.add(entity);
        }
		return filteredList;
    }
    
    // ===================================================================================
    //                                                                    Behavior Command
    //                                                                    ================
    protected ${glInsertEntityCommand} createInsertEntityCommand(${glEntityInterfaceName} entity) {
        assertBehaviorCommandInvoker("createInsertEntityCommand");
        return xsetupEntityCommand(new ${glInsertEntityCommand}(), entity);
    }

    protected ${glUpdateEntityCommand} createUpdateEntityCommand(${glEntityInterfaceName} entity) {
        assertBehaviorCommandInvoker("createUpdateEntityCommand");
        return xsetupEntityCommand(new ${glUpdateEntityCommand}(), entity);
    }

    protected ${glUpdateNonstrictEntityCommand} createUpdateNonstrictEntityCommand(${glEntityInterfaceName} entity) {
        assertBehaviorCommandInvoker("createUpdateNonstrictEntityCommand");
        return xsetupEntityCommand(new ${glUpdateNonstrictEntityCommand}(), entity);
    }

    protected ${glDeleteEntityCommand} createDeleteEntityCommand(${glEntityInterfaceName} entity) {
        assertBehaviorCommandInvoker("createDeleteEntityCommand");
        return xsetupEntityCommand(new ${glDeleteEntityCommand}(), entity);
    }

    protected ${glDeleteNonstrictEntityCommand} createDeleteNonstrictEntityCommand(${glEntityInterfaceName} entity) {
        assertBehaviorCommandInvoker("createDeleteNonstrictEntityCommand");
        return xsetupEntityCommand(new ${glDeleteNonstrictEntityCommand}(), entity);
    }

    private <COMMAND extends ${glAbstractEntityCommand}> COMMAND xsetupEntityCommand(COMMAND command, ${glEntityInterfaceName} entity) {
        command.setTableDbName(getTableDbName());
        _behaviorCommandInvoker.injectComponentProperty(command);
        command.setEntityType(entity.getClass());
        command.setEntity(entity);
        return command;
    }

    protected ${glBatchInsertEntityCommand} createBatchInsertEntityCommand(List<? extends ${glEntityInterfaceName}> entityList) {
        assertBehaviorCommandInvoker("createBatchInsertEntityCommand");
        return xsetupListEntityCommand(new ${glBatchInsertEntityCommand}(), entityList);
    }

    protected ${glBatchUpdateEntityCommand} createBatchUpdateEntityCommand(List<? extends ${glEntityInterfaceName}> entityList) {
        assertBehaviorCommandInvoker("createBatchUpdateEntityCommand");
        return xsetupListEntityCommand(new ${glBatchUpdateEntityCommand}(), entityList);
    }

    protected ${glBatchUpdateNonstrictEntityCommand} createBatchUpdateNonstrictEntityCommand(List<? extends ${glEntityInterfaceName}> entityList) {
        assertBehaviorCommandInvoker("createBatchUpdateNonstrictEntityCommand");
        return xsetupListEntityCommand(new ${glBatchUpdateNonstrictEntityCommand}(), entityList);
    }

    protected ${glBatchDeleteEntityCommand} createBatchDeleteEntityCommand(List<? extends ${glEntityInterfaceName}> entityList) {
        assertBehaviorCommandInvoker("createBatchDeleteEntityCommand");
        return xsetupListEntityCommand(new ${glBatchDeleteEntityCommand}(), entityList);
    }

    protected ${glBatchDeleteNonstrictEntityCommand} createBatchDeleteNonstrictEntityCommand(List<? extends ${glEntityInterfaceName}> entityList) {
        assertBehaviorCommandInvoker("createBatchDeleteNonstrictEntityCommand");
        return xsetupListEntityCommand(new ${glBatchDeleteNonstrictEntityCommand}(), entityList);
    }

    /**
     * @param <COMMAND> The type of behavior command for list entity.
     * @param command The command of behavior. (NotNull)
     * @param entityList The list of entity. (NotNull, NotEmpty)
     * @return The command of behavior. (NotNull)
     */
    private <COMMAND extends ${glAbstractListEntityCommand}> COMMAND xsetupListEntityCommand(COMMAND command, List<? extends ${glEntityInterfaceName}> entityList) {
        command.setTableDbName(getTableDbName());
        _behaviorCommandInvoker.injectComponentProperty(command);
        command.setEntityType(entityList.get(0).getClass()); // *The list should not be empty!
        command.setEntityList(entityList);
        return command;
    }

    protected ${glQueryDeleteCBCommand} createQueryDeleteCBCommand(${glConditionBeanInterfaceName} cb) {
        assertBehaviorCommandInvoker("createQueryDeleteCBCommand");
        final ${glQueryDeleteCBCommand} cmd = new ${glQueryDeleteCBCommand}();
        cmd.setTableDbName(getTableDbName());
        _behaviorCommandInvoker.injectComponentProperty(cmd);
        cmd.setConditionBeanType(cb.getClass());
        cmd.setConditionBean(cb);
        return cmd;
    }

    protected ${glQueryUpdateEntityCBCommand} createQueryUpdateEntityCBCommand(${glEntityInterfaceName} entity, ${glConditionBeanInterfaceName} cb) {
        assertBehaviorCommandInvoker("createQueryUpdateEntityCBCommand");
        final ${glQueryUpdateEntityCBCommand} cmd = new ${glQueryUpdateEntityCBCommand}();
        cmd.setTableDbName(getTableDbName());
        _behaviorCommandInvoker.injectComponentProperty(cmd);
        cmd.setConditionBeanType(cb.getClass());
        cmd.setConditionBean(cb);
        cmd.setEntityType(entity.getClass());
        cmd.setEntity(entity);
        return cmd;
    }
}
