${database.allClassCopyright}package ${glPackageBaseBhv};

#set ($myClassName = "${myBaseBhvClassName}")

import java.util.List;

import ${glPackageBaseCommon}.*;
#if (${table.hasOnlyOnePrimaryKey()} && $table.hasReferrerAsMany())
import ${glPackageBaseCommonBhvLoad}.${glLoadReferrerOptionName};
import ${glPackageBaseCommonBhvSetup}.${glConditionBeanSetupperName};
#end
import ${glPackageBaseCommonBhvSetup}.${glValueLabelSetupperName};
#if ($database.isMakeFlatExpansion())
import ${glPackageBaseCommonDBMetaHierarchy}.${glHierarchyArrangerName};
import ${glPackageBaseCommonDBMetaHierarchy}.${glHierarchyBasicRequestName};
import ${glPackageBaseCommonDBMetaHierarchy}.${glHierarchyRequestName};
#end
import ${glPackageBaseCommonCBean}.${glConditionBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glListResultBeanName};
import ${glPackageBaseCommonCBean}.${glPagingHandlerName};
import ${glPackageBaseCommonCBean}.${glPagingInvokerName};
import ${glPackageBaseCommonCBean}.${glPagingBeanInterfaceName};
import ${glPackageBaseCommonCBean}.${glPagingResultBeanName};
import ${glPackageBaseCommonDBMeta}.${glDBMetaInterfaceName};
#if (${table.hasOnlyOnePrimaryKey()} && $table.hasReferrerAsMany())
import ${glPackageExtendedBhv}.*;
#end
import ${glPackageExtendedDao}.*;
import ${glPackageExtendedEntity}.*;
import ${myDBMetaPackageName}.*;
import ${glPackageCB}.*;

#set ($myExtendClassName = "")
#if ($table.isWritable())
  #set ($myExtendClassName = "${glBehaviorWritableAbstractName}")
#else
  #set ($myExtendClassName = "${glBehaviorReadableAbstractName}")
#end

/**
 * The behavior of ${table.name}.
 * <pre>
 * [primary-key]
 *     ${table.primaryKeyNameCommaString}
 * 
 * [column]
 *     ${table.columnNameCommaString}
 * 
 * [sequence]
 *     ${table.definedSequenceName}
 * 
 * [identity]
 *     ${table.identityColumnName}
 * 
 * [version-no]
 *     ${table.versionNoColumnName}
 * 
 * [foreign-table]
 *     ${table.foreignTableNameCommaString}
 * 
 * [referrer-table]
 *     ${table.referrerTableNameCommaString}
 * 
 * [foreign-property]
 *     ${table.foreignPropertyNameCommaString}
 * 
 * [referrer-property]
 *     ${table.referrerPropertyNameCommaString}
 * </pre>
 * @author ${database.ClassAuthor}
 */${database.outputSuppressWarningsAfterLineSeparator()}
public abstract class ${myClassName} extends ${glPackageBaseCommonBhv}.${myExtendClassName} {

    // ===================================================================================
    //                                                                          Definition
    //                                                                          ==========
    ${database.behaviorQueryPathBeginMark}
    ${database.behaviorQueryPathEndMark}

    // ===================================================================================
    //                                                                           Attribute
    //                                                                           =========
    protected ${myExtendedDaoClassName} _dao;

    // ===================================================================================
    //                                                                          Table name
    //                                                                          ==========
    /** @return The name on database of table. (NotNull) */
    public String getTableDbName() { return "${table.name}"; }

    // ===================================================================================
    //                                                                              DBMeta
    //                                                                              ======
    /** @return The meta data of the database. (NotNull) */
    public ${glDBMetaInterfaceName} getDBMeta() { return ${myDBMetaClassName}.getInstance(); }

    /** @return The meta data of the database as my table type. (NotNull) */
    public ${myDBMetaClassName} getMyDBMeta() { return ${myDBMetaClassName}.getInstance(); }

    // ===================================================================================
    //                                                                        Dao Accessor
    //                                                                        ============
    public ${myExtendedDaoClassName} getMyDao() { return _dao; }
    public void setMyDao(${myExtendedDaoClassName} dao) { assertObjectNotNull("dao", dao); _dao = dao; }
    public ${glDaoReadableInterfaceName} getDaoReadable() { return getMyDao(); }
#if ($table.isWritable())
    public ${glDaoWritableInterfaceName} getDaoWritable() { return getMyDao(); }
#end

    // ===================================================================================
    //                                                                        New Instance
    //                                                                        ============
    public ${glEntityInterfaceName} newEntity() { return newMyEntity(); }
    public ${glConditionBeanInterfaceName} newConditionBean() { return newMyConditionBean(); }
    public ${myExtendedObjectClassName} newMyEntity() { return new ${myExtendedObjectClassName}(); }
    public ${myConditionBeanClassName} newMyConditionBean() { return new ${myConditionBeanClassName}(); }

    // ===================================================================================
    //                                                                        Count Select
    //                                                                        ============
    /**
     * Select the count of the condition-bean. {IgnorePagingCondition}
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @return The selected count.
     */
    public int selectCount(${myConditionBeanClassName} cb) {
        assertConditionBeanNotNull(cb);
        return delegateSelectCount(cb);
    }

    // ===================================================================================
    //                                                                       Entity Select
    //                                                                       =============
    /**
     * Select the entity by the condition-bean.
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @return The selected entity. (Nullalble)
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public ${myExtendedObjectClassName} selectEntity(final ${myConditionBeanClassName} cb) {
        return helpSelectEntityInternally(cb, new InternalSelectEntityCallback<${myExtendedObjectClassName}, ${myConditionBeanClassName}>() {
            public List<${myExtendedObjectClassName}> callbackSelectList(${myConditionBeanClassName} cb) { return selectList(cb); } });
    }

    /**
     * Select the entity by the condition-bean with deleted check.
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @return The selected entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public ${myExtendedObjectClassName} selectEntityWithDeletedCheck(final ${myConditionBeanClassName} cb) {
        return helpSelectEntityWithDeletedCheckInternally(cb, new InternalSelectEntityWithDeletedCheckCallback<${myExtendedObjectClassName}, ${myConditionBeanClassName}>() {
            public List<${myExtendedObjectClassName}> callbackSelectList(${myConditionBeanClassName} cb) { return selectList(cb); } });
    }

#if ($table.hasPrimaryKey())
    /* (non-javadoc)
     * Select the entity with deleted check. {by primary-key value}
     * @param primaryKey The keys of primary.
     * @return The selected entity. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public ${myExtendedObjectClassName} selectByPKValueWithDeletedCheck(${table.PrimaryKeyArgsString}) {
        ${myExtendedObjectClassName} entity = new ${myExtendedObjectClassName}();
        ${table.getPrimaryKeyArgsSetupString('entity')}
        final ${myConditionBeanClassName} cb = newMyConditionBean();
        cb.acceptPrimaryKeyMapString(getDBMeta().extractPrimaryKeyMapString(entity));
        return selectEntityWithDeletedCheck(cb);
    }
#end

    // ===================================================================================
    //                                                                         List Select
    //                                                                         ===========
    /**
     * Select the list as result-bean.
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @return The result-bean of selected list. (NotNull)
     */
    public ${glListResultBeanName}<${myExtendedObjectClassName}> selectList(${myConditionBeanClassName} cb) {
        assertConditionBeanNotNull(cb);
        return new ${glPackageBaseCommonCBean}.${glResultBeanBuilderName}<${myExtendedObjectClassName}>(getTableDbName()).buildListResultBean(cb, delegateSelectList(cb));
    }

    // ===================================================================================
    //                                                                         Page Select
    //                                                                         ===========
    /**
     * Select the page as result-bean.
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @return The result-bean of selected page. (NotNull)
     */
    public ${glPagingResultBeanName}<${myExtendedObjectClassName}> selectPage(final ${myConditionBeanClassName} cb) {
        assertConditionBeanNotNull(cb);
        final ${glPagingInvokerName}<${myExtendedObjectClassName}> invoker = new ${glPagingInvokerName}<${myExtendedObjectClassName}>(getTableDbName());
        final ${glPagingHandlerName}<${myExtendedObjectClassName}> handler = new ${glPagingHandlerName}<${myExtendedObjectClassName}>() {
            public ${glPagingBeanInterfaceName} getPagingBean() { return cb; }
            public int count() { return selectCount(cb); }
            public List<${myExtendedObjectClassName}> paging() { return selectList(cb); }
        };
        return invoker.invokePaging(handler);
    }

    // ===================================================================================
    //                                                                      Various Select
    //                                                                      ==============
    /**
     * Select the list of value-label.
     * @param cb The condition-bean of ${myExtendedObjectClassName}. (NotNull)
     * @param valueLabelSetupper The setupper of value-label. (NotNull)
     * @return The list of value-label. (NotNull)
     */
    public List<java.util.Map<String, Object>> selectValueLabelList(${myConditionBeanClassName} cb, ${glValueLabelSetupperName}<${myExtendedObjectClassName}> valueLabelSetupper) {
        return createValueLabelList(selectList(cb), valueLabelSetupper);
    }

#if ($table.isUseSequence())
    // ===================================================================================
    //                                                                            Sequence
    //                                                                            ========
    /**
     * Select the next value as sequence.
     * @return The next value. (NotNull)
     */
    public ${table.sequenceReturnType} selectNextVal() {
        return delegateSelectNextVal();
    }
#end

#if (${table.hasOnlyOnePrimaryKey()})
    // ===================================================================================
    //                                                                       Load Referrer
    //                                                                       =============
#foreach ($referrer in $table.refererList)
#set ($referrerTable = $referrer.Table)
#set ($referrerEntityClassName = "${referrer.referrerTableExtendedEntityClassName}")
#set ($referrerBhvClassName = "${referrer.referrerTableExtendedBehaviorClassName}")
#set ($referrerCBClassName = "${referrer.referrerTableExtendedConditionBeanClassName}")
#set ($referrerVariableName = "${glChildrenVariablePrefix}${referrer.RefrererPropertyNameInitCap}")
#set ($referrerEntityLongClassName = "${glPackageExtendedEntity}.${referrerEntityClassName}")
#set ($genericPKMyEntityMap = "${table.getPrimaryKeyJavaNativeAsOne()}, ${myExtendedObjectClassName}")
#set ($genericPKChildListMap = "${table.getPrimaryKeyJavaNativeAsOne()}, List<${referrerEntityClassName}>")
#if (!${referrer.isOneToOne()})
#if ($database.isMakeBehaviorNoConditionLoadReferrer())
    /**
     * {Refer to overload method that has an argument of condition-bean setupper.}
     * @param ${myEntityListVariableName} The entity list of ${table.javaBeansRulePropertyName}. (NotNull)
     */
    public void load${referrer.referrerJavaBeansRulePropertyNameInitCap}(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        load${referrer.referrerJavaBeansRulePropertyNameInitCap}(${myEntityListVariableName}, new ${glConditionBeanSetupperName}<${referrerCBClassName}>() {
            public void setup(${referrerCBClassName} cb) {}});
    }
#end
    /**
     * Load referrer of ${referrer.referrerJavaBeansRulePropertyName} with the setupper for condition-bean of referrer. <br />
     * About internal policy, the value of primary key(and others too) is treated as case-insensitive. <br />
     * The conditionBean that the setupper provides have settings before you touch it. It is as follows:
     * <pre>
     * cb.query().set${referrer.getLocalColumnJavaNameAsOne()}_InScope(pkList);
     * cb.query().addOrderBy_${referrer.getLocalColumnJavaNameAsOne()}_Asc();
     * </pre>
     * @param ${myEntityListVariableName} The entity list of ${table.javaBeansRulePropertyName}. (NotNull)
     * @param conditionBeanSetupper Referrer condition setupper instance for registering referrer condition. (NotNull)
     */
    public void load${referrer.referrerJavaBeansRulePropertyNameInitCap}(List<${myExtendedObjectClassName}> ${myEntityListVariableName}, ${glConditionBeanSetupperName}<${referrerCBClassName}> conditionBeanSetupper) {
        assertObjectNotNull("${myEntityListVariableName}<${myExtendedObjectClassName}>", ${myEntityListVariableName});
        assertObjectNotNull("conditionBeanSetupper<${referrerCBClassName}>", conditionBeanSetupper);
        if (${myEntityListVariableName}.isEmpty()) { return; }
        load${referrer.referrerJavaBeansRulePropertyNameInitCap}(${myEntityListVariableName}, new ${glLoadReferrerOptionName}<${referrerCBClassName}, ${referrerEntityClassName}>(conditionBeanSetupper));
    }
    /**
     * {Refer to overload method that has an argument of condition-bean setupper.}
     * @param ${myEntityListVariableName} The entity list of ${table.javaBeansRulePropertyName}. (NotNull)
     * @param loadReferrerOption the option of load-referrer. (NotNull)
     */
    public void load${referrer.refererJavaBeansRulePropertyNameInitCap}(List<${myExtendedObjectClassName}> ${myEntityListVariableName}, ${glLoadReferrerOptionName}<${referrerCBClassName}, ${referrerEntityClassName}> loadReferrerOption) {
        assertObjectNotNull("${myEntityListVariableName}<${myExtendedObjectClassName}>", ${myEntityListVariableName});
        assertObjectNotNull("loadReferrerOption<${referrerEntityClassName}, ${referrerCBClassName}>", loadReferrerOption);
        if (${myEntityListVariableName}.isEmpty()) { return; }
        final ${referrerBhvClassName} referrerBhv = getBehaviorSelector().select(${referrerBhvClassName}.class);
        helpLoadReferrerInternally(${myEntityListVariableName}, loadReferrerOption, new InternalLoadReferrerCallback<${myExtendedObjectClassName}, ${table.getPrimaryKeyJavaNativeAsOne()}, ${referrerCBClassName}, ${referrerEntityClassName}>() {
            public ${table.getPrimaryKeyJavaNativeAsOne()} callbackBase_getPrimaryKeyValue(${myExtendedObjectClassName} entity) { return entity.get${table.getPrimaryKeyJavaNameAsOne()}(); }
            public void callbackBase_setReferrerList(${myExtendedObjectClassName} entity, List<${referrerEntityClassName}> referrerList) { entity.set${referrer.referrerPropertyNameInitCap}(referrerList); }
            public ${referrerCBClassName} callbackReferrer_newMyConditionBean() { return referrerBhv.newMyConditionBean(); }
            public void callbackReferrer_queryForeignKeyInScope(${referrerCBClassName} cb, List<${table.getPrimaryKeyJavaNativeAsOne()}> pkList) { cb.query().set${referrer.getLocalColumnJavaNameAsOne()}_InScope(pkList); }
            public void callbackReferrer_queryAddOrderByForeignKeyAsc(${referrerCBClassName} cb) { cb.query().addOrderBy_${referrer.getLocalColumnJavaNameAsOne()}_Asc(); }
            public List<${referrerEntityClassName}> callbackReferrer_selectList(${referrerCBClassName} cb) { return referrerBhv.selectList(cb); }
            public ${table.getPrimaryKeyJavaNativeAsOne()} callbackReferrer_getForeignKeyValue(${referrerEntityClassName} entity) { return entity.get${referrer.getLocalColumnJavaNameAsOne()}(); }
            public void callbackReferrer_setForeignEntity(${referrerEntityClassName} referrerEntity, ${myExtendedObjectClassName} baseEntity) { referrerEntity.set${referrer.foreignPropertyNameInitCap}(baseEntity); }
        } );
    }
#end
#end
#end

    // ===================================================================================
    //                                                                    Pull Out Foreign
    //                                                                    ================
#foreach ($foreignKeys in $table.foreignKeys)
#set ($foreignEntityClassName = "${foreignKeys.foreignTableExtendedEntityClassName}")

    /**
     * Pull out the list of foreign table '${foreignEntityClassName}'.
     * @param ${myEntityListVariableName} The list of ${table.uncapitalisedJavaName}. (NotNull)
     * @return The list of foreign table. (NotNull)
     */
    public List<${foreignEntityClassName}> pullout${foreignKeys.foreignPropertyNameInitCap}(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        return helpPulloutInternally(${myEntityListVariableName}, new InternalPulloutCallback<${myExtendedObjectClassName}, ${foreignEntityClassName}>() {
            public ${foreignEntityClassName} callbackGetForeignEntity(${myExtendedObjectClassName} entity) { return entity.get${foreignKeys.foreignPropertyNameInitCap}(); } });
    }
#end
#foreach ($referrer in $table.referrers)
  #set ($referrerTable = $referrer.table)
  #set ($referrerEntityClassName = "${glProjectPrefix}${referrerTable.javaName}")
  #if (${referrer.isOneToOne()})

    /**
     * Pull out the list of referrer-as-one table '${referrerEntityClassName}'.
     * @param ${myEntityListVariableName} The list of ${table.uncapitalisedJavaName}. (NotNull)
     * @return The list of referrer-as-one table. (NotNull)
     */
    public List<${referrerEntityClassName}> pullout${referrer.referrerPropertyNameInitCapAsOne}(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        return helpPulloutInternally(${myEntityListVariableName}, new InternalPulloutCallback<${myExtendedObjectClassName}, ${referrerEntityClassName}>() {
            public ${referrerEntityClassName} callbackGetForeignEntity(${myExtendedObjectClassName} entity) { return entity.get${referrer.referrerPropertyNameInitCapAsOne}(); } });
    }
  #end
#end
#if ($table.isWritable())

    // ===================================================================================
    //                                                                       Entity Update
    //                                                                       =============
    /**
     * Insert the entity.
     * @param ${myEntityVariableName} The entity of insert target. (NotNull)
     */
    public void insert(${myExtendedObjectClassName} ${myEntityVariableName}) {
        assertEntityNotNull(${myEntityVariableName});
        delegateInsert(${myEntityVariableName});
    }

    @Override
    protected void doCreate(${glEntityInterfaceName} ${myEntityVariableName}) {
        insert((${myExtendedObjectClassName})${myEntityVariableName});
    }

    /**
     * Update the entity modified-only. {UpdateCountZeroException, ConcurrencyControl}
     * @param ${myEntityVariableName} The entity of update target. (NotNull) {PrimaryKeyRequired, ConcurrencyColumnRequired}
#if ($table.hasOptimisticLock())
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
#else
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
#end
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void update(final ${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpUpdateInternally(${myEntityVariableName}, new InternalUpdateCallback<${myExtendedObjectClassName}>() {
            public int callbackDelegateUpdate(${myExtendedObjectClassName} entity) { return delegateUpdate(entity); } });
    }

    @Override
    protected void doModify(${glEntityInterfaceName} entity) {
        update((${myExtendedObjectClassName})entity);
    }
#if ($table.hasOptimisticLock())
    
    /**
     * Update the entity non-strictly modified-only. {UpdateCountZeroException, NonConcurrencyControl}
     * @param ${myEntityVariableName} The entity of update target. (NotNull) {PrimaryKeyRequired}
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void updateNonstrict(final ${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpUpdateNonstrictInternally(${myEntityVariableName}, new InternalUpdateNonstrictCallback<${myExtendedObjectClassName}>() {
            public int callbackDelegateUpdateNonstrict(${myExtendedObjectClassName} entity) { return delegateUpdateNonstrict(entity); } });
    }
#end

    @Override
    protected void doModifyNonstrict(${glEntityInterfaceName} entity) {
#if ($database.isVersionAfter1040() && ($table.isUseUpdateDate() || $table.isUseVersionNo()))
        updateNonstrict((${myExtendedObjectClassName})entity);
#else
        update((${myExtendedObjectClassName})entity);
#end
    }

    /**
     * Insert or update the entity modified-only. {ConcurrencyControl(when update)}
     * @param ${myEntityVariableName} The entity of insert or update target. (NotNull)
#if ($table.hasOptimisticLock())
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
#else
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
#end
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void insertOrUpdate(final ${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpInsertOrUpdateInternally(${myEntityVariableName}, new InternalInsertOrUpdateCallback<${myExtendedObjectClassName}, ${myConditionBeanClassName}>() {
            public void callbackInsert(${myExtendedObjectClassName} entity) { insert(entity); }
            public void callbackUpdate(${myExtendedObjectClassName} entity) { update(entity); }
            public ${myConditionBeanClassName} callbackNewMyConditionBean() { return newMyConditionBean(); }
            public int callbackSelectCount(${myConditionBeanClassName} cb) { return selectCount(cb); }
        });
    }

    @Override
    protected void doCreateOrUpdate(${glEntityInterfaceName} ${myEntityVariableName}) {
        insertOrUpdate((${myExtendedObjectClassName})${myEntityVariableName});
    }
#if ($table.hasOptimisticLock())

    /**
     * Insert or update the entity non-strictly modified-only. {NonConcurrencyControl(when update)}
     * @param ${myEntityVariableName} The entity of insert or update target. (NotNull)
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void insertOrUpdateNonstrict(${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpInsertOrUpdateInternally(${myEntityVariableName}, new InternalInsertOrUpdateNonstrictCallback<${myExtendedObjectClassName}>() {
            public void callbackInsert(${myExtendedObjectClassName} entity) { insert(entity); }
            public void callbackUpdateNonstrict(${myExtendedObjectClassName} entity) { updateNonstrict(entity); }
        });
    }
#end

    @Override
    protected void doCreateOrUpdateNonstrict(${glEntityInterfaceName} entity) {
#if ($table.isUseUpdateDate() || $table.isUseVersionNo())
        insertOrUpdateNonstrict((${myExtendedObjectClassName})entity);
#else
        insertOrUpdate((${myExtendedObjectClassName})entity);
#end
    }

    /**
     * Delete the entity. {UpdateCountZeroException, ConcurrencyControl}
     * @param ${myEntityVariableName} The entity of delete target. (NotNull) {PrimaryKeyRequired, ConcurrencyColumnRequired}
#if ($table.hasOptimisticLock())
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
#else
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
#end
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void delete(${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpDeleteInternally(${myEntityVariableName}, new InternalDeleteCallback<${myExtendedObjectClassName}>() {
            public int callbackDelegateDelete(${myExtendedObjectClassName} entity) { return delegateDelete(entity); } });
    }

    @Override
    protected void doRemove(${glEntityInterfaceName} ${myEntityVariableName}) {
        delete((${myExtendedObjectClassName})${myEntityVariableName});
    }
#if ($table.hasOptimisticLock())

    /**
     * Delete the entity non-strictly. {UpdateCountZeroException, NonConcurrencyControl}
     * @param ${myEntityVariableName} Entity. (NotNull) {PrimaryKeyRequired}
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void deleteNonstrict(${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpDeleteNonstrictInternally(${myEntityVariableName}, new InternalDeleteNonstrictCallback<${myExtendedObjectClassName}>() {
            public int callbackDelegateDeleteNonstrict(${myExtendedObjectClassName} entity) { return delegateDeleteNonstrict(entity); } });
    }

    /**
     * Delete the entity non-strictly ignoring deleted. {UpdateCountZeroException, NonConcurrencyControl}
     * @param ${myEntityVariableName} Entity. (NotNull) {PrimaryKeyRequired}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException}
     * @exception ${glPackageBaseCommonException}.${glEntityDuplicatedException} When the entity has been duplicated.
     */
    public void deleteNonstrictIgnoreDeleted(${myExtendedObjectClassName} ${myEntityVariableName}) {
        helpDeleteNonstrictIgnoreDeletedInternally(${myEntityVariableName}, new InternalDeleteNonstrictIgnoreDeletedCallback<${myExtendedObjectClassName}>() {
            public int callbackDelegateDeleteNonstrict(${myExtendedObjectClassName} entity) { return delegateDeleteNonstrict(entity); } });
    }
#end

#set ($batchUpdateReturnType = "")
#if ($database.isVersionAfter1047())
  #set ($batchUpdateReturnType = "int[]")
#else
  #set ($batchUpdateReturnType = "int")
#end
#set ($batchUpdateReturnValueMethod = "")
#if ($database.isVersionAfter1047())
  #set ($batchUpdateReturnValueMethod = ".length")
#else
  #set ($batchUpdateReturnValueMethod = "")
#end

    // ===================================================================================
    //                                                                        Batch Update
    //                                                                        ============
    /**
     * Batch insert the list. This method use 'Batch Update' of java.sql.PreparedStatement.
     * @param ${myEntityListVariableName} The list of the entity. (NotNull)
     * @return The array of inserted count.
     */
    public ${batchUpdateReturnType} batchInsert(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        return delegateInsertList(${myEntityListVariableName});
    }

    /**
     * Batch update the list. All columns are update target. {NOT modified only} <br />
     * This method use 'Batch Update' of java.sql.PreparedStatement.
     * @param ${myEntityListVariableName} The list of the entity. (NotNull)
     * @return The array of updated count.
#if ($table.hasOptimisticLock())
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
#else
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
#end
     */
    public ${batchUpdateReturnType} batchUpdate(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        return delegateUpdateList(${myEntityListVariableName});
    }
#if ($table.hasOptimisticLock())

    /**
     * Batch update the list non-strictly. All columns are update target. {NOT modified only} <br />
     * This method use 'Batch Update' of java.sql.PreparedStatement.
     * @param ${myEntityListVariableName} The list of the entity. (NotNull)
     * @return The array of updated count.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     */
    public ${batchUpdateReturnType} batchUpdateNonstrict(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        return delegateUpdateListNonstrict(${myEntityListVariableName});
    }
#end

    /**
     * Batch delete the list. <br />
     * This method use 'Batch Update' of java.sql.PreparedStatement.
     * @param ${myEntityListVariableName} The list of the entity. (NotNull)
     * @return The array of deleted count.
#if ($table.hasOptimisticLock())
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyUpdatedException} When the entity has already been updated.
#else
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
#end
     */
    public ${batchUpdateReturnType} batchDelete(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        return delegateDeleteList(${myEntityListVariableName});
    }
#if ($table.hasOptimisticLock())

    /**
     * Batch delete the list non-strictly. <br />
     * This method use 'Batch Update' of java.sql.PreparedStatement.
     * @param ${myEntityListVariableName} The list of the entity. (NotNull)
     * @return The array of deleted count.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException} When the entity has already been deleted.
     */
    public ${batchUpdateReturnType} batchDeleteNonstrict(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        return delegateDeleteListNonstrict(${myEntityListVariableName});
    }
#end

    // ===================================================================================
    //                                                                       Query  Update
    //                                                                       =============
#if (${table.hasOnlyOnePrimaryKey()})
    /**
     * Query update the several entities. {NoConcurrencyControl}
     * @param ${myEntityVariableName} Entity. (NotNull) {PrimaryKeyNotRequired}
     * @param cb Condition-bean. (NotNull)
     * @return The updated count.
     */
    public int queryUpdate(${myExtendedObjectClassName} ${myEntityVariableName}, ${myConditionBeanClassName} cb) {
        assertObjectNotNull("${myEntityVariableName}", ${myEntityVariableName}); assertConditionBeanNotNull(cb);
        setupCommonColumnOfUpdateIfNeeds(${myEntityVariableName});
        filterEntityOfUpdate(${myEntityVariableName}); assertEntityOfUpdate(${myEntityVariableName});
        return getMyDao().updateByQuery(cb, ${myEntityVariableName});
    }

    /**
     * Query delete the several entities. {NoConcurrencyControl}
     * @param cb Condition-bean. (NotNull)
     * @return The deleted count.
     */
    public int queryDelete(${myConditionBeanClassName} cb) {
        assertConditionBeanNotNull(cb);
        return getMyDao().deleteByQuery(cb);
    }
#end

    // ===================================================================================
    //                                                                      Various Update
    //                                                                      ==============
#if ($database.isMakeBehaviorCopyInsert())
#if ($table.isUseIdentity())
#if ($table.hasPrimaryKey())

    /* (non-javadoc) 
     * Copy-insert.
     * @param primaryKey Primary-keys. (NotNull)
     * @return Inserted count.
     * @exception ${glPackageBaseCommonException}.${glEntityAlreadyDeletedException}
     */
    public int copyInsertByPKValueAfterSelect(${table.PrimaryKeyArgsString}) {
        ${myExtendedObjectClassName} entity = new ${myExtendedObjectClassName}();
        ${table.getPrimaryKeyArgsSetupString('entity')}
        final ${myConditionBeanClassName} cb = newMyConditionBean();
        cb.acceptPrimaryKeyMapString(getDBMeta().extractPrimaryKeyMapString(entity));
        final ${myExtendedObjectClassName} currentEntity = selectEntityWithDeletedCheck(cb);
        return delegateInsert(currentEntity);
    }
#end

    /**
     * Filter 'copy-insert' entity.
     * @param ${myEntityVariableName} Entity. (NotNull)
     */
    protected void filterCopyInsertEntity(${myExtendedObjectClassName} ${myEntityVariableName}) {
    }
#end
#end
#if ($database.isMakeBehaviorLoopUpdate())
    /**
     * Loop update modified elements only.
     * @param ${myEntityListVariableName} The list of entity. (NotNull and Empty OK)
     */
    public void loopUpdateModifiedElementsOnly(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        for (${myExtendedObjectClassName} entity : ${myEntityListVariableName}) { if (entity.hasModification()) { update(entity); } }
    }

#if ($table.isUseUpdateDate() || $table.isUseVersionNo())
    /**
     * Loop update modified elements only non-strictly.
     * @param ${myEntityListVariableName} The list of entity. (NotNull and Empty OK)
     */
    public void loopUpdateModifiedElementsOnlyNonstrict(List<${myExtendedObjectClassName}> ${myEntityListVariableName}) {
        assertObjectNotNull("${myEntityListVariableName}", ${myEntityListVariableName});
        for (${myExtendedObjectClassName} entity : ${myEntityListVariableName}) { if (entity.hasModification()) { updateNonstrict(entity); } }
    }
#end
#end
#else
  #if ($table.isAvailableNonPrimaryKeyWritable())

    // ===================================================================================
    //                                                                       Entity Update
    //                                                                       =============
    /**
     * Insert.
     * @param ${myEntityVariableName} Entity. (NotNull)
     */
    public void insert(${myExtendedObjectClassName} ${myEntityVariableName}) {
        assertEntityNotNull(${myEntityVariableName});
        delegateInsert(${myEntityVariableName});
    }
  #end
#end

    // ===================================================================================
    //                                                                     Delegate Method
    //                                                                     ===============
    // -----------------------------------------------------
    //                                                Select
    //                                                ------
    ${database.behaviorDelegateModifier} int delegateGetCountAll() { return getMyDao().getCountAll(); }
    ${database.behaviorDelegateModifier} List<${myExtendedObjectClassName}> delegateGetListAll() { return getMyDao().getListAll(); }
#if ($table.hasPrimaryKey())
    ${database.behaviorDelegateModifier} ${myExtendedObjectClassName} delegateGetEntity(${table.PrimaryKeyArgsString}) { return getMyDao().getEntity(${table.getPrimaryKeyUncapitalisedJavaNameCommaString()}); }
#end
    ${database.behaviorDelegateModifier} int delegateSelectCount(${myConditionBeanClassName} cb) { assertConditionBeanNotNull(cb); return getMyDao().selectCount(cb); }
    ${database.behaviorDelegateModifier} ${myExtendedObjectClassName} delegateSelectEntity(${myConditionBeanClassName} cb) { assertConditionBeanNotNull(cb); return getMyDao().selectEntity(cb); }
    ${database.behaviorDelegateModifier} List<${myExtendedObjectClassName}> delegateSelectList(${myConditionBeanClassName} cb) { assertConditionBeanNotNull(cb); return getMyDao().selectList(cb); }
#if ($table.isUseSequence())
    ${database.behaviorDelegateModifier} ${table.sequenceReturnType} delegateSelectNextVal() { return getMyDao().selectNextVal(); }
#end
#if ($table.isWritable())

    // -----------------------------------------------------
    //                                                Update
    //                                                ------
    ${database.behaviorDelegateModifier} int delegateInsert(${myExtendedObjectClassName} e) { if (!processBeforeInsert(e)) { return 1; } return getMyDao().insert(e); }
    ${database.behaviorDelegateModifier} int delegateUpdate(${myExtendedObjectClassName} e) { if (!processBeforeUpdate(e)) { return 1; } return getMyDao().updateModifiedOnly(e); }
#if ($table.hasOptimisticLock())
    ${database.behaviorDelegateModifier} int delegateUpdateNonstrict(${myExtendedObjectClassName} e) { if (!processBeforeUpdate(e)) { return 1; } return getMyDao().updateNonstrictModifiedOnly(e); }
#end
    ${database.behaviorDelegateModifier} int delegateDelete(${myExtendedObjectClassName} e) { if (!processBeforeDelete(e)) { return 1; } return getMyDao().delete(e); }
#if ($table.hasOptimisticLock())
    ${database.behaviorDelegateModifier} int delegateDeleteNonstrict(${myExtendedObjectClassName} e) { if (!processBeforeDelete(e)) { return 1; } return getMyDao().deleteNonstrict(e); }
#end
#set ($batchUpdateReturnType = "")
#if ($database.isVersionAfter1047())
  #set ($batchUpdateReturnType = "int[]")
#else
  #set ($batchUpdateReturnType = "int")
#end

    ${database.behaviorDelegateModifier} ${batchUpdateReturnType} delegateInsertList(List<${myExtendedObjectClassName}> ls) {
        assertObjectNotNull("${myEntityListVariableName}", ls); return getMyDao().insertList(helpFilterBeforeInsertInternally(ls));
    }
    ${database.behaviorDelegateModifier} ${batchUpdateReturnType} delegateUpdateList(List<${myExtendedObjectClassName}> ls) {
        assertObjectNotNull("${myEntityListVariableName}", ls); return getMyDao().updateList(helpFilterBeforeUpdateInternally(ls));
    }
#if ($table.hasOptimisticLock())
    ${database.behaviorDelegateModifier} ${batchUpdateReturnType} delegateUpdateListNonstrict(List<${myExtendedObjectClassName}> ls) {
        assertObjectNotNull("${myEntityListVariableName}", ls); return getMyDao().updateListNonstrict(helpFilterBeforeUpdateInternally(ls));
    }
#end
    ${database.behaviorDelegateModifier} ${batchUpdateReturnType} delegateDeleteList(List<${myExtendedObjectClassName}> ls) {
        assertObjectNotNull("${myEntityListVariableName}", ls); return getMyDao().deleteList(helpFilterBeforeDeleteInternally(ls));
    }
#if ($table.hasOptimisticLock())
    ${database.behaviorDelegateModifier} ${batchUpdateReturnType} delegateDeleteListNonstrict(List<${myExtendedObjectClassName}> ls) {
        assertObjectNotNull("${myEntityListVariableName}", ls); return getMyDao().deleteListNonstrict(helpFilterBeforeDeleteInternally(ls));
    }
#end
#else
#if ($table.isAvailableNonPrimaryKeyWritable())
    ${database.behaviorDelegateModifier} int delegateInsert(${myExtendedObjectClassName} entity) {
        assertEntityNotNull(entity);// If this table use identity, the entity does not have primary-key.
        return getMyDao().insert(entity);
    }
#end
#end
#if ($table.hasBehaviorFilterBeforeColumn())

    // ===================================================================================
    //                                                                     Filter Override
    //                                                                     ===============
#if ($table.hasBehaviorFilterBeforeInsertColumn())
    @Override
    protected void filterEntityOfInsert(${glEntityInterfaceName} entity) {
        filterEntityOfInsert(entity);
#foreach ($column in $table.behaviorFilterBeforeInsertColumnList)
        downcast(entity).set${column.javaName}(${column.behaviorFilterBeforeInsertColumnExpression});
#end
    }
#end
#if ($table.hasBehaviorFilterBeforeUpdateColumn())
    @Override
    protected void filterEntityOfUpdate(${glEntityInterfaceName} entity) {
        filterEntityOfUpdate(entity);
#foreach ($column in $table.behaviorFilterBeforeUpdateColumnList)
        downcast(entity).set${column.javaName}(${column.behaviorFilterBeforeUpdateColumnExpression});
#end
    }
#end
#end
#if ($database.isMakeFlatExpansion())

    // ===================================================================================
    //                                                                           Hierarchy
    //                                                                           =========
    /**
     * Create the basic request of hierarchy of ${myExtendedObjectClassName}..
     * @param sourceList The list of source. (NotNull)
     * @param <SOURCE> The type of source.
     * @return Hierarchy request of ${myExtendedObjectClassName}. (NotNull)
     */
    public <SOURCE> ${glHierarchyBasicRequestName}<${myExtendedObjectClassName}, ${myDBMetaClassName}.${table.relationTraceClassName}RelationTrace> createHierarchyBasicRequest(List<SOURCE> sourceList) {
        final ${glHierarchyBasicRequestName}<${myExtendedObjectClassName}, ${myDBMetaClassName}.${table.relationTraceClassName}RelationTrace> request = new ${glHierarchyBasicRequestName}<${myExtendedObjectClassName}, ${myDBMetaClassName}.${table.relationTraceClassName}RelationTrace>(${myExtendedObjectClassName}.class);
        request.registerSourceList(sourceList);
        return request;
    }

    /**
     * Arrange hierarchy.
     * @param request Hierarchy request of ${myExtendedObjectClassName}. (NotNull)
     * @return The list of ${myExtendedObjectClassName}. (NotNull)
     */
    public List<${myExtendedObjectClassName}> arrangeHierarchy(${glHierarchyRequestName}<${myExtendedObjectClassName}> request) {
        return new ${glHierarchyArrangerName}<${myExtendedObjectClassName}>().arrangeHierarchy(request);
    }
#end

    // ===================================================================================
    //                                                                Optimistic Lock Info
    //                                                                ====================
    @Override
    protected boolean hasVersionNoValue(${glEntityInterfaceName} entity) {
#if ($table.isUseVersionNo())
        return !(downcast(entity).get${table.versionNoJavaName}() + "").equals("null");// For primitive type
#else
        return false;
#end
    }

    @Override
    protected boolean hasUpdateDateValue(${glEntityInterfaceName} entity) {
#if ($table.isUseUpdateDate())
        return downcast(entity).get${table.updateDateJavaName}() != null;
#else
        return false;
#end
    }

    // ===================================================================================
    //                                                                              Helper
    //                                                                              ======
    protected ${myExtendedObjectClassName} downcast(${glEntityInterfaceName} entity) {
        return helpDowncastInternally(entity, ${myExtendedObjectClassName}.class);
    }
}
